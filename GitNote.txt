(一)文件基本管理	
	一.创建版本库--提交文件
		1.创建一个空目录：mkdir GITSPACES 进入该目录cd GITSPACES 显示当前目录pwd 
			通过git init命令把这个目录变成Git可以管理的仓库
		2.用命令git add告诉Git，把文件添加到仓库
			git add readme.txt
		3.用命令git commit告诉Git，把文件提交到仓库
			git commit -m "wrote a readme file"			//-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的
		4.更改文件后,使用git status查看仓库当前状态
	二.文件发生变化的处理
		1.运行git status命令查看当前版本信息,当文件发生变化会提示哪个文件有变化
			git status 
		2.运行git diff命令查看具体内容不同的地方
			git diff GitNote.txt
		3.当确认不同之处没问题之后继续使用add commit命令提交文件
	三.版本回退
		1.使用git log查看版本记录
			git log
			也可使用git log --pretty=oneling查看精简版日志
		2.使用git reset --hard HEAD^回退到上一版本,HEAD表示当前版本，上一个版本就是HEAD^，上上一个版本就是HEAD^^，
		当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100
			git reset --hard HEAD^
		3.回到上一版本之后在想回到最新的版本需要在命令行窗口没有关闭的前提下,在之前的记录中找到需要的版本的commit id
			git reset --hard 3628164(版本号)
		4.使用cat GitNote.txt可查看当前文档内容,不支持中文
		5.当命令窗口被关闭后,可以使用git reflog查看每一次的命令id,就可以回到需要的版本
			git reflog
	四.管理修改
		1.实验操作
			修改-->add-->修改-->commit,由此可知只有第一次修改的内容被添加到了暂存区
		2.使用git diff HEAD -- GitNote.txt查看工作去和版本库的区别
			git diff HEAD -- readme.txt
		3.可以看出第二次修改的内容没有提交到存储区,需要再次add commit操作
	五.撤销修改
		1.当更改的内容没有被添加到stage时,可以使用git checkout将工作区更改的内容回到stage区最新的内容,意味着工作区的修改被撤销
			git checkout -- GitNote.txt
		2.当更改的内容被add到暂存区,但是没有commit时,可以使用git reset HEAD GitNote.txt来撤销暂存区的修改
			git reset HEAD GitNote.txt
	六.删除操作
		1.文件删除可以直接在工作区中删除或者使用rm直接删除
		2.删除后工作区和版本库中的内容不符
			2.1可以使用git rm 文件并且git commit操作后文件从版本库中删除
			2.2文件误删,版本库中让然存在,使用checkout操作恢复最新状态
				git checkout -- GitNote.txt
(二).远程仓库
	一.init Operator
		1.创建SSH key
			ssh-keygen -t rsa -C "youremail@example.com"
		2.登陆GitHub，打开“Account settings”，“SSH Keys”页面,点击Add SSH Key,将生成的id_rsa.pub添加
	二.添加远程仓库
		1.Create new repository,在Repository name填入自己仓库的名字,创建即可(My Name:GIESPACES)
		2.目前在GitHub上的这个GIESPACES仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，
		然后，把本地仓库的内容推送到GitHub仓库
			git remote add origin git@github.com:michaelliao/learngit.git			//p.s:github.com后面是:,不是/,其中origin是远程库的名字,可以自定义
		3.将本地库的所有内容推送到远程库上
			git push -u origin master
		4.当你第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告：
			The authenticity of host 'github.com (xx.xx.xx.xx)' can't be established.
			RSA key fingerprint is xx.xx.xx.xx.xx.
			Are you sure you want to continue connecting (yes/no)?
			输入yes,回车就行,这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，
			需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器
		由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，
		还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令:git push origin master
		如果第一次执行git remote add origin操作出现偏差时需要重新添加一次,可以执行git remote remove origin(远程仓库的name),然后重新添加即可
	三.从远程库克隆
		1.创建一个新的远程库,gitSkills
		2.git clone git@github.com:heiheiyuan/gitSkills.git从远程仓库clone到本地
(三).分支管理
	一.创建与合并分支
		1.创建dev分支，然后切换到dev分支
			git checkout -b dev(git checkout命令加上-b参数表示创建并切换，相当于以下两条命令:git branch dev    git checkout dev)
		2.git branch命令查看当前分支
			git branch
		3.完成任务后提交代码,并将分支切回到master
			git checkout master
		4.将dev分支的工作成果合并到master分支上
			git merge dev		//git merge命令用于合并指定分支到当前分支
		5.合并成功后删除dev分支
			git branch -d dev
		6.查看分支,发现只有一个master
			git branch
	二.解决冲突
		1.准备新的分支
			git checkout -b feature1
		2.文件发生改动
		3.在feature1上提交
		4.切换到master分支
			git checkout master
		5.文件发生变化,在master分支上提交
		6.目前两个分支各自有新的提交
		7.此时进行合并会有冲突发生
			git merge feature1
		8.Git会说明GitNote.txt文件存在冲突，必须手动解决冲突后再提交,git status也可以告诉我们冲突的文件,我们可以直接查看GitNote.txt的内容
	三.分支管理策略
		1.合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。
		  如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息
		2.创建并切换分支dev
			git checkout -b dev
		3.修改文件内容并提交
		4.切回master
		5.合并dev分支,并使用--on--ff参数,表示禁用fast forward
			git merge --no-ff -m "merge with no-ff" dev
			本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去
		6.合并后使用git log查看分支历史
			git log --graph --pretty=oneline --abbrev-commit
	四.bug分支
		1.在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。
		  当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但是当前正在dev上进行的工作还没有提交
			$ git status
			# On branch dev
			# Changes to be committed:
			#   (use "git reset HEAD <file>..." to unstage)
			#
			#       new file:   hello.py
			#
			# Changes not staged for commit:
			#   (use "git add <file>..." to update what will be committed)
			#   (use "git checkout -- <file>..." to discard changes in working directory)
			#
			#       modified:   readme.txt
			#
		2.工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？
			Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作
				$ git stash
				Saved working directory and index state WIP on dev: 6224937 add merge
				HEAD is now at 6224937 add merge
		3.用git status查看工作区是干净的（除非有没有被Git管理的文件），可以放心地创建分支来修复bug,假定需要在master分支上修复，就从master创建临时分支
			$ git checkout master
			Switched to branch 'master'
			Your branch is ahead of 'origin/master' by 6 commits.
			$ git checkout -b issue-101
			Switched to a new branch 'issue-101'
		4.修复bug完成之后提交,切换至master,并合并,最后删除分支
		5.bug修复完成后需要回到dev分支上干活
			$ git checkout dev
			Switched to branch 'dev'
			$ git status
			# On branch dev
			nothing to commit (working directory clean)
		6.工作区是干净的,用git stash list命令,工作现场存到哪去了
			$ git stash list
			stash@{0}: WIP on dev: 6224937 add merge
		7.一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；
		  另一种方式是用git stash pop，恢复的同时把stash内容也删了
		  $ git stash pop
			# On branch dev
			# Changes to be committed:
			#   (use "git reset HEAD <file>..." to unstage)
			#
			#       new file:   hello.py
			#
			# Changes not staged for commit:
			#   (use "git add <file>..." to update what will be committed)
			#   (use "git checkout -- <file>..." to discard changes in working directory)
			#
			#       modified:   readme.txt
			#
			Dropped refs/stash@{0} (f624f8e5f082f2df2bed8a4e09c12fd2943bdd40)
		8.再用git stash list查看就没有任何stash内容了
		9.多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令：
			$ git stash apply stash@{0}
	五.Feature分支
		1.开发新的功能最好新建一个新的feature分支,完成后合并,删除
		2.当功能开发完成后,准备提交时,得知该功能取消,需要删除该分支
			git branch -d feature-vulcan
		3.销毁失败。Git友情提醒，feature-vulcan分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用命令
			git branch -D feature-vulcan
		4.使用git branch -D feature-vulcan强行删除
	六.多人协作
		1.当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。
		要查看远程库的信息，用git remote,也可使用git remote -v显示更详细的信息
		2.多人协作时，大家都会往master和dev分支上推送各自的修改
			2.1模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆
				git clone git@github.com:heiheiyuan/GITSPACES.git
			2.2当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的master分支。不信可以用git branch命令看看
				$ git branch
				* master
			2.3小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支:
				git checkout -b dev origin/dev
			2.4现在，他就可以在dev上继续修改，然后，时不时地把dev分支push到远程：
				$ git commit -m "add /usr/bin/env"
				$ git push origin dev
			2.5你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送：
				$ git add hello.py 
				$ git commit -m "add coding: utf-8"
				$ git push origin dev
				推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，
				Git已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送：
					$ git pull
					remote: Counting objects: 5, done.
					remote: Compressing objects: 100% (2/2), done.
					remote: Total 3 (delta 0), reused 3 (delta 0)
					Unpacking objects: 100% (3/3), done.
					From github.com:michaelliao/learngit
					   fc38031..291bea8  dev        -> origin/dev
					There is no tracking information for the current branch.
					Please specify which branch you want to merge with.
					See git-pull(1) for details

						git pull <remote> <branch>

					If you wish to set tracking information for this branch you can do so with:

						git branch --set-upstream dev origin/<branch>
					git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接：
						$ git branch --set-upstream dev origin/dev
						Branch dev set up to track remote branch dev from origin.
					紧接着才可以pull
						$ git pull
						Auto-merging hello.py
						CONFLICT (content): Merge conflict in hello.py
						Automatic merge failed; fix conflicts and then commit the result.
					pull成功后合并会有冲突,手动解决冲突后可以提交代码
		多人协作的工作模式:
			首先，可以试图用git push origin branch-name推送自己的修改；
			如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；
			如果合并有冲突，则解决冲突，并在本地提交；
			没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！
			如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令
				git branch --set-upstream branch-name origin/branch-name。
